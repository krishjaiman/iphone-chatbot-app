# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14YyqCYl2ngMtqjykW28GXaYGUlWHwfHd
"""

import os
os.environ["TRANSFORMERS_NO_TF"] = "1"
api_key = os.environ.get("SERP_API_KEY")

import streamlit as st
import pandas as pd
import requests
from transformers import pipeline , AutoModelForCausalLM , AutoTokenizer


# --- Setup ---
st.set_page_config(page_title="iPhone Chatbot", layout="centered")

# Load LLM
LLM_PIPELINE = pipeline("text-generation", model="TinyLlama/TinyLlama-1.1B-step-50K-105b")

# --- Data ---
IPHONE_MODELS = [
    "iPhone 15 Pro Max", "iPhone 15 Pro", "iPhone 15", "iPhone 15 Plus",
    "iPhone 14 Pro Max", "iPhone 14 Pro", "iPhone 14", "iPhone 14 Plus",
    "iPhone 13 Pro Max", "iPhone 13 Pro", "iPhone 13", "iPhone 13 Mini"
]
FEATURES = [
    "camera", "battery", "display", "screen", "processor", "performance",
    "storage", "design", "durability", "charging", "speaker", "audio",
    "face id", "touch id", "software", "iOS", "price", "value", "weight", "dimensions"
]
all_specs = [
    {"model_name": "iPhone 15 Pro Max", "camera": "48MP", "battery": "4422mAh", "display": "6.7-inch OLED"},
    {"model_name": "iPhone 14", "camera": "12MP", "battery": "3279mAh", "display": "6.1-inch OLED"},
    {"model_name": "iPhone 13 Pro Max", "camera": "12MP", "battery": "4352mAh", "display": "6.7-inch OLED"},
    {"model_name": "iPhone 13 Mini", "camera": "12MP", "battery": "2438mAh", "display": "5.4-inch OLED"}
]
SPECS_DF = pd.DataFrame(all_specs)

# Your SerpAPI key (replace with your real key or put in .streamlit/secrets.toml)
SERP_API_KEY = api_key

# --- Helper Functions ---
def identify_query_type(query):
    review_keywords = ["opinion", "review", "experience", "feel", "user", "people", "like", "dislike"]
    if any(word in query.lower() for word in review_keywords):
        return "review"
    else:
        return "specs"

def extract_model_and_feature(query):
    prompt = f"Extract the iPhone model and feature from this query:\n\"{query}\"\nReturn format:\nModel: <model>\nFeature: <feature>"
    response = LLM_PIPELINE(prompt, max_length=100)[0]['generated_text']

    # Simple parsing
    model_line = next((line for line in response.split('\n') if line.lower().startswith('model:')), '')
    feature_line = next((line for line in response.split('\n') if line.lower().startswith('feature:')), '')

    model = model_line.split(':', 1)[1].strip() if ':' in model_line else None
    feature = feature_line.split(':', 1)[1].strip() if ':' in feature_line else None

    return model, feature


def serpapi_search(query, api_key, num_results=3):
    url = "https://serpapi.com/search"
    params = {
        "engine": "duckduckgo",
        "q": query,
        "api_key": api_key
    }
    response = requests.get(url, params=params)
    results = []
    if response.status_code == 200:
        data = response.json()
        for item in data.get("organic_results", []):
            results.append({
                "title": item.get("title", ""),
                "snippet": item.get("snippet", ""),
                "url": item.get("link", "")
            })
    return results

def synthesize_answer(query, snippets):
    context = "\n".join([f"- {s['snippet']}" for s in snippets if s.get('snippet')])
    prompt = (
        "You are an assistant answering iPhone questions using real user reviews and expert opinions.\n"
        f"Here are some relevant web snippets:\n{context}\n\n"
        f"Now answer this user question based on the above information:\n{query}\n\nAnswer:"
    )
    result = LLM_PIPELINE(prompt, max_length=512, do_sample=True)[0]['generated_text']
    return result.split("Answer:")[-1].strip()

# --- Streamlit UI ---
st.title("iPhone Chatbot")
st.write("Ask about iPhone specs or user opinions!")

user_query = st.text_input("Your question:")
if st.button("Ask"):
    if user_query:
        with st.spinner("Thinking..."):
            model, features = extract_model_and_feature(user_query)
            if not model:
                st.error("Sorry, I couldn't identify which iPhone model you're asking about.")
            else:
                query_type = identify_query_type(user_query)
                if query_type == "specs":
                    row = SPECS_DF[SPECS_DF['model_name'].str.lower() == model.lower()]
                    if row.empty:
                        st.write("No specs found.")
                    else:
                        st.subheader(f"{model} Specs")
                        for col in row.columns:
                            if col != "model_name":
                                st.write(f"**{col.capitalize()}**: {row.iloc[0][col]}")
                else:
                    if not SERP_API_KEY:
                        st.error("Opinion queries require a SerpAPI key, but none is set.")
                    else:
                        search_terms = f"{model} {' '.join(features)} user opinions" if features else f"{model} user reviews"
                        snippets = serpapi_search(search_terms, SERP_API_KEY)
                        if not snippets:
                            st.error("Couldn't find relevant opinions.")
                        else:
                            answer = synthesize_answer(user_query, snippets)
                            st.subheader("Answer")
                            st.write(answer)
    else:
        st.warning("Please enter a question.")

